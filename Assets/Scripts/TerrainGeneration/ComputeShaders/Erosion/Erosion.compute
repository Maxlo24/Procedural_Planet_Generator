// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

int sizeX, sizeY;
int borderSize;
int lifetime;
int brushSize;
float initialVelocity;
float acceleration;
float drag;
float initialWater;
float sedimentCapacityFactor;
float depositRatio;
float erosionRatio;
float gravity;
float evaporationRatio;

RWStructuredBuffer<float> heights;
StructuredBuffer<float2> initialPositions;
StructuredBuffer<float3> brush;

StructuredBuffer<int> brushIndices;
StructuredBuffer<float> brushWeights;
int brushLength;


float3 calculateHeightAndGradiant(float posX, float posY, int sizeX, int sizeY)
{
    int x = (int) posX;
    int y = (int) posY;
    float u = posX - x;
    float v = posY - y;
    
    float hxy = heights[x * sizeY + y];
    float hx1y = heights[(x + 1) * sizeY + y];
    float hxy1 = heights[x * sizeY + (y + 1)];
    float hx1y1 = heights[(x + 1) * sizeY + (y + 1)];
    
    float height = (1 - v) * ((1 - u) * hxy + u * hx1y) + v * ((1 - u) * hxy1 + u * hx1y1);
    float gradX = (1 - v) * (hx1y - hxy) + v * (hx1y1 - hxy1);
    float gradY = (1 - u) * (hxy1 - hxy) + u * (hx1y1 - hx1y);
    
    return float3(height, gradX, gradY);
}

[numthreads(512,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float posX = initialPositions[id.x].x;
    float posY = initialPositions[id.x].y;
    float newPosX = posX, newPosY = posY;
    
    float speed = initialVelocity;
    
    float dirX = 0;
    float dirY = 0;
    float currHeight = 0;
    
    float water = initialWater;
    float sediment = 0;

	float3 _currentErosion;
    
	for (int life = 0; life < lifetime; life++)
	{
		int x = (int)posX;
		int y = (int)posY;
		float u = posX - x;
		float v = posY - y;
		
		float3 heightGrad = calculateHeightAndGradiant(posX, posY, sizeX, sizeY);
		dirX = (1 - drag) * dirX - acceleration * heightGrad.y;
		dirY = (1 - drag) * dirY - acceleration * heightGrad.z;
		currHeight = heightGrad.x;

		float len = max(0.0001, sqrt(dirX * dirX + dirY * dirY));
		dirX /= len;
		dirY /= len;
		newPosX += dirX;
		newPosY += dirY;

		if (newPosX < borderSize || newPosY < borderSize || newPosX >= sizeX - borderSize || newPosY >= sizeY - borderSize || (dirX == 0 && dirY == 0))
		{
			break;
		}

		float newheight = calculateHeightAndGradiant(newPosX, newPosY, sizeX, sizeY).x;

		float hDiff = newheight - currHeight;
		float sedimentCapacity = abs(hDiff * speed * water * sedimentCapacityFactor);

		if (hDiff > 0)
		{
			float depositAmount = max(-hDiff, -sediment);
			sediment += depositAmount;
			_currentErosion = float3(posX, posY, -depositAmount);
		}
		else
		{
			float erosionAmount = 0;
			if (sedimentCapacity - sediment < 0)
			{
				erosionAmount = (sedimentCapacity - sediment) * depositRatio;
			}
			else
			{
				erosionAmount = min(-hDiff, (sedimentCapacity - sediment) * erosionRatio);
			}
			sediment += erosionAmount;
			_currentErosion = float3(posX, posY, -erosionAmount);
		}

		float amount = _currentErosion.z;

		heights[x * sizeY + y] += amount * (1 - u) * (1 - v);
		heights[(x+1) * sizeY + y] += amount * (u) * (1 - v);
		heights[x * sizeY + (y+1)] += amount * (1 - u) * (v);
		heights[(x + 1) * sizeY + (y + 1)] += amount * (u) * (v);

		posX = newPosX;
		posY = newPosY;

		speed = sqrt(max(0, speed * speed - hDiff * gravity));
		water *= (1 - evaporationRatio);
	}
}
