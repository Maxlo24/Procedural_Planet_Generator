// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

int sizeX, sizeY;
int borderSize;
int lifetime;
int brushSize;
float initialVelocity;
float acceleration;
float drag;
float initialWater;
float sedimentCapacityFactor;
float depositRatio;
float erosionRatio;
float gravity;
float evaporationRatio;
bool erodeEnabled;
bool erosionMapUsed;

RWStructuredBuffer<float> heights;
StructuredBuffer<float2> initialPositions;
StructuredBuffer<float> erosionMap;

StructuredBuffer<float> brushWeights;

float bilinearInterpolation(StructuredBuffer<float> array, float posX, float posY, int sizeX, int sizeY)
{
	int x = (int)posX;
	int y = (int)posY;
	float u = posX - x;
	float v = posY - y;

	float hxy = array[x * sizeY + y];
	float hx1y = array[(x + 1) * sizeY + y];
	float hxy1 = array[x * sizeY + (y + 1)];
	float hx1y1 = array[(x + 1) * sizeY + (y + 1)];

	return (1 - v) * ((1 - u) * hxy + u * hx1y) + v * ((1 - u) * hxy1 + u * hx1y1);
}


float3 calculateHeightAndGradiant(float posX, float posY, int sizeX, int sizeY)
{
	int x = (int)posX;
	int y = (int)posY;
	float u = posX - x;
	float v = posY - y;

	float hxy = heights[x * sizeY + y];
	float hx1y = heights[(x + 1) * sizeY + y];
	float hxy1 = heights[x * sizeY + (y + 1)];
	float hx1y1 = heights[(x + 1) * sizeY + (y + 1)];

	float height = (1 - v) * ((1 - u) * hxy + u * hx1y) + v * ((1 - u) * hxy1 + u * hx1y1);
	float gradX = (1 - v) * (hx1y - hxy) + v * (hx1y1 - hxy1);
	float gradY = (1 - u) * (hxy1 - hxy) + u * (hx1y1 - hx1y);

	return float3(height, gradX, gradY);
}

[numthreads(512, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float posX = initialPositions[id.x].x;
	float posY = initialPositions[id.x].y;
	float newPosX = posX, newPosY = posY;

	float speed = initialVelocity;

	float dirX = 0;
	float dirY = 0;
	float currHeight = 0;

	float water = initialWater;
	float sediment = 0;

	float3 _currentErosion;

	for (int life = 0; life < lifetime; life++)
	{
		int x = (int)posX;
		int y = (int)posY;
		float u = posX - x;
		float v = posY - y;

		float3 heightGrad = calculateHeightAndGradiant(posX, posY, sizeX, sizeY);
		dirX = (1 - drag) * dirX - acceleration * heightGrad.y;
		dirY = (1 - drag) * dirY - acceleration * heightGrad.z;
		currHeight = heightGrad.x;

		float len = max(0.0001, sqrt(dirX * dirX + dirY * dirY));
		dirX /= len;
		dirY /= len;
		newPosX += dirX;
		newPosY += dirY;

		if (newPosX < borderSize || newPosY < borderSize || newPosX >= sizeX - borderSize || newPosY >= sizeY - borderSize || (dirX == 0 && dirY == 0))
		{
			break;
		}

		float newheight = calculateHeightAndGradiant(newPosX, newPosY, sizeX, sizeY).x;

		float hDiff = newheight - currHeight;
		float sedimentCapacity = abs(hDiff * speed * water * sedimentCapacityFactor);

		if (hDiff > 0)
		{
			float depositAmount = max(-hDiff, -sediment);
			sediment += depositAmount;
			_currentErosion = float3(posX, posY, -depositAmount);
		}
		else
		{
			float erosionAmount = 0;
			float mapErosionRatio = 1;
			if (erosionMapUsed)
			{
				mapErosionRatio = bilinearInterpolation(erosionMap, posX, posY, sizeX, sizeY);
			}

			if (sedimentCapacity - sediment < 0)
			{
				erosionAmount = (sedimentCapacity - sediment) * depositRatio * mapErosionRatio;
			}
			else
			{
				erosionAmount = min(-hDiff, (sedimentCapacity - sediment) * erosionRatio) * mapErosionRatio;
			}
			sediment += erosionAmount;
			_currentErosion = float3(posX, posY, -erosionAmount);
		}

		float amount = _currentErosion.z;

		if (erodeEnabled || amount > 0)
		{
			if (brushSize == 0)
			{
				heights[x * sizeY + y] += amount * (1 - u) * (1 - v);
				heights[(x + 1) * sizeY + y] += amount * (u) * (1 - v);
				heights[x * sizeY + (y + 1)] += amount * (1 - u) * (v);
				heights[(x + 1) * sizeY + (y + 1)] += amount * (u) * (v);
			}
			else
			{
				float2 brushMiddle = float2(brushSize + 1, brushSize + 1);
				for (int xp = x - brushSize; xp <= x + brushSize + 1; xp++)
				{
					for (int yp = y - brushSize; yp <= y + brushSize + 1; yp++)
					{
						if (xp >= 0 && yp >= 0 && xp < sizeX && yp < sizeY)
						{
							float bxp = xp - posX + brushMiddle.x;
							float byp = yp - posY + brushMiddle.y;
							float brushAmount = bilinearInterpolation(brushWeights, bxp, byp, 2 * brushSize + 3, 2 * brushSize + 3);
							//float weight = brushWeights[(xp - x + brushSize) * (brushSize * 2 + 1) + (yp - y + brushSize)];
							heights[xp * sizeY + yp] += amount * brushWeights[(int) bxp * (2 * brushSize + 3) + (int)byp]/*brushAmount*/;
						}
					}
				}
			}
		}

		posX = newPosX;
		posY = newPosY;

		speed = sqrt(max(0, speed * speed - hDiff * gravity));
		water *= (1 - evaporationRatio);
	}
}
