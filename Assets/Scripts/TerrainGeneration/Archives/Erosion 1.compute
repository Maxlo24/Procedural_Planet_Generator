// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

int sizeX, sizeY;
int lifetime;
int brushSize;
float initialVelocity;
float acceleration;
float drag;
float initialWater;
float sedimentCapacityFactor;
float depositRatio;
float erosionRatio;
float gravity;
float evaporationRatio;
float depositThreshold;

RWStructuredBuffer<float> heights;
StructuredBuffer<float2> initialPositions;
StructuredBuffer<float3> brush;

StructuredBuffer<int> brushIndices;
StructuredBuffer<float> brushWeights;
int brushLength;


float3 calculateHeightAndGrad(float posX, float posY, int sizeX, int sizeY)
{
    int x = (int) posX;
    int y = (int) posY;
    
    int left = max(0, x - 1) * sizeY + y;
    int right = min(sizeX - 1, x + 1) * sizeY + y;
    int down = x * sizeY + max(0, y - 1);
    int up = x * sizeY + min(sizeY - 1, y + 1);
    
    float height = heights[x * sizeY + y];
    
    float gradX = heights[right] - heights[left];
    float gradY = heights[up] - heights[down];
    
    return float3(height, gradX, gradY);
}

float3 calculateHeightAndGrad2(float posX, float posY, int sizeX, int sizeY)
{
    int x = (int) posX;
    int y = (int) posY;
    float u = posX - x;
    float v = posY - y;
    
    int xn = min(x + 1, sizeX - 1);
    int yn = min(y + 1, sizeY - 1);
    
    float a = heights[x * sizeY + y];
    float b = heights[xn * sizeY + y];
    float c = heights[x * sizeY + yn];
    float d = heights[xn * sizeY + yn];
    
    float height = (1 - v) * ((1 - u) * a + u * b) + v * ((1 - u) * c + u * d);
    float gradX = (1 - v) * (b - a) + v * (d - c);
    float gradY = (1 - u) * (c - a) + u * (d - b);
    
    return float3(height, gradX, gradY);
}

[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float posX = initialPositions[id.x].x;
    float posY = initialPositions[id.x].y;
    float nposX = posX, nposY = posY;
    
    float speed = initialVelocity;
    
    float dirX = 0;
    float dirY = 0;
    float currHeight = 0;
    
    float water = initialWater;
    float sediment = 0;
    
    float3 cs[300];
    
    for (int i = 0; i < 300; i++)
    {
        cs[i] = float3(0, 0, 0);
    }
    
        for (int life = 0; life < lifetime; life++)
        {
            float3 heightGrad = calculateHeightAndGrad2(posX, posY, sizeX, sizeY);
            dirX = (1 - drag) * dirX - acceleration * heightGrad.y;
            dirY = (1 - drag) * dirY - acceleration * heightGrad.z;
            currHeight = heightGrad.x;
        
            float len = max(0.0001, sqrt(dirX * dirX + dirY * dirY));
            dirX /= len;
            dirY /= len;
            nposX += dirX;
            nposY += dirY;
        
            if (nposX < 0 || nposY < 0 || nposX >= sizeX || nposY >= sizeY || (dirX == 0 && dirY == 0))
            {
                break;
            }
        
            float newheight = calculateHeightAndGrad2(nposX, nposY, sizeX, sizeY).x;
        
            float hDiff = newheight - currHeight;
            float sedimentCapacity = abs(hDiff * speed * water * sedimentCapacityFactor); //multiply by deltaheight for test
        
            if (hDiff > 0)
            {
                float depositAmount = max(-hDiff, -sediment);
                //if (depositAmount > depositThreshold)
                //{
                //    depositAmount = depositThreshold;
                //}
                sediment += depositAmount;
                cs[life] = float3(posX, posY, -depositAmount);
            }
            else
            {
                float erosionAmount = 0;
                if (sedimentCapacity - sediment < 0)
                {
                    erosionAmount = (sedimentCapacity - sediment) * depositRatio;
                }
                else
                {
                    erosionAmount = min(-hDiff, (sedimentCapacity - sediment) * erosionRatio);
                }
                sediment += erosionAmount;
                cs[life] = float3(posX, posY, -erosionAmount);
            }
        
            posX = nposX;
            posY = nposY;
        
            speed = sqrt(max(0, speed * speed - hDiff * gravity));
            water *= (1 - evaporationRatio);
        }
    
    for (int life2 = 0; life2 < lifetime; life2++)
    {
        int dropId = life2;
        float3 posAmt = cs[dropId];
        float posX = posAmt.x, posY = posAmt.y, amt = posAmt.z;
        int x = (int) posX, y = (int) posY;
        float u = posX - x, v = posY - y;
        
        int xn = min(x + 1, sizeX - 1);
        int yn = min(y + 1, sizeY - 1);
        
        if(1)   //set this condtiton to 1 to stop using diffrent brush sizes
        {
            heights[x * sizeY + y] += amt * (1 - u) * (1 - v);
            heights[xn * sizeY + y] += amt * (u) * (1 - v);
            heights[x * sizeY + yn] += amt * (1 - u) * (v);
            heights[xn * sizeY + yn] += amt * (u) * (v);
        }
        else
        {
            int dropletIndex = x * sizeY + y;
            for (int i = 0; i < brushLength; i++) {
                int erodeIndex = dropletIndex + brushIndices[i];

                float weightedErodeAmount = amt * brushWeights[i];
                float deltaSediment = (heights[erodeIndex] < weightedErodeAmount) ? heights[erodeIndex] : weightedErodeAmount;
                heights[erodeIndex] -= deltaSediment;
                //sediment += deltaSediment;
            }
    //        int Size = (2 * (int)brushSize + 1) * (2 * (int)brushSize + 1);;
    //        
    //        for (int i = 0; i < (2 * (int)brushSize + 1); i++)
    //        {
				//for (int j = 0; j < (2 * (int)brushSize + 1); j++)
				//{
				//	brush[i * (2 * (int)brushSize + 1) + j] = 1;
				//	//int x = (int)posX + i - (int)brushSize;
				//	//int y = (int)posY + j - (int)brushSize;
				//	//if (x >= 0 && y >= 0 && x < sizeX && y < sizeY)
				//	//{
				//	//	heights[x * sizeY + y] += amt * brush[i * (2 * (int)brushSize + 1) + j];
				//	//}
				//}
    //        }
            
            //for (int i = 0; i < 4 * brushSize * brushSize; i++)
            //{
            //    int iX = round(brush[i].x), iY = round(brush[i].y);
            //    float wt = brush[i].z;
            //    
            //    if (x + iX < 0 || y + iY < 0 || x + iX >= sizeX - 1 || y + iY >= sizeY - 1)
            //    {
            //        continue;
            //    }
            //    else
            //    {
            //        float p = (iX > 0) ? u : 1 - u;
            //        float q = (iY > 0) ? v : 1 - v;
            //        
            //        heights[(x + iX) * sizeY + y + iY] += p * q * wt * amt;
            //    }
            //}
        }
    }
}
